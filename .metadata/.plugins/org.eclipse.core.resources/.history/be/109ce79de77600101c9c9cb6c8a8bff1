/*
 * sistema.c
 * Modos, velocidad, paquetes (AUTO), semáforo, EEPROM y display + temperaturas no bloqueantes.
 *
 * LCD 20x4:
 *  L0: MODO (mantener)
 *  L1: VEL y PAQ (agregado)
 *  L2: TIn y TEx (mantener)
 *
 * Paquetes (BTN_1):
 *  - MANUAL -> cambia a AUTO
 *  - AUTO   -> PAQ++ (0->1->2, saturado en 2), VEL=PAQ, timeout 10s para volver PAQ=0/VEL=0
 */

#include "main.h"
#include "display.h"
#include "cinta.h"
#include "task_sensor.h"
#include "eprom.h"
#include "sen_temp.h"
#include "logger.h"

#include <string.h>
#include <stdio.h>
#include <stdlib.h>     // abs()

/* ========================= Configuración ========================= */

/* Pines del semáforo (ajustar si hace falta) */
#define SEM_GPIO             GPIOC
#define SEM_PIN_ROJO         GPIO_PIN_8
#define SEM_PIN_AMARILLO     GPIO_PIN_6
#define SEM_PIN_VERDE        GPIO_PIN_5

/* EEPROM: direcciones para modo y velocidad */
#define EEPROM_ADDR_MODO     0x0000
#define EEPROM_ADDR_VEL      0x0001

/* Periodos (ms) */
#define LCD_PERIOD_MS        200u
#define BLINK_PERIOD_MS      400u
#define PAQ_TIMEOUT_MS       10000u  /* <<< timeout paquetes: 10 s */

/* Límites */
#define VEL_MIN              0
#define VEL_MAX              2

/* Botones (según task_sensor) */
#define BTN_TOGGLE_FALLA     BTN_3   /* FALLA ON/OFF */
#define BTN_PAQ_O_MODO       BTN_1   /* MANUAL->AUTO, en AUTO: PAQ++ */
#define BTN_CYCLE_VEL        BTN_2   /* En MANUAL: VEL 0->1->2->0 */

/* ADCs provistos por CubeMX */
extern ADC_HandleTypeDef hadc1;   // ADC1: interna
extern ADC_HandleTypeDef hadc2;   // ADC2: externa (PA0 -> CH0)

/* I2C para EEPROM */
extern I2C_HandleTypeDef hi2c1;

/* ========================= Estado local ========================= */

static Cinta   s_cinta;                 /* modo y velocidad */
static uint8_t s_vel_guardada = 0;      /* backup velocidad (persistencia) */
static uint8_t s_modo_guardado = 1;     /* backup modo (persistencia) */

static uint8_t  s_btn_prev[BTN_QTY];    /* para flancos */

static uint32_t s_paq_count = 0;        /* contador de paquetes (0..2) */
static uint32_t s_last_paq_tick = 0;    /* timestamp del último paquete en AUTO */

/* Temporizadores (no bloqueantes) */
static uint32_t s_next_lcd_tick   = 0;
static uint32_t s_next_blink_tick = 0;
static uint8_t  s_blink           = 0;

/* Temperaturas */
static float s_tin = 0.0f;    /* °C interna */
static float s_tex = 0.0f;    /* 0..100 externa (pot) */

/* LCD buffer */
static char s_line[21];        /* 20 col + '\0' */

/* ========================= Helpers ========================= */

static void lcd_print_padded(uint8_t col, uint8_t row, const char* txt)
{
    displayCharPositionWrite(col, row);
    memset(s_line, ' ', 20);
    s_line[20] = '\0';
    size_t n = strlen(txt);
    if (n > 20) n = 20;
    memcpy(s_line, txt, n);
    displayStringWrite(s_line);
}

static const char* modo_to_str(int8_t modo)
{
    switch (modo) {
        case 0: return "MODO: FALLA ";
        case 1: return "MODO: MANUAL";
        case 2: return "MODO: AUTO  ";
        default: return "MODO: ---   ";
    }
}

/* Flanco ascendente desde estado estable de task_sensor */
static uint8_t btn_rising_edge(task_sensor_id_t id)
{
    uint8_t cur = task_sensor_get_state(id) ? 1 : 0;
    uint8_t rising = (cur == 1) && (s_btn_prev[id] == 0);
    s_btn_prev[id] = cur;
    return rising;
}

/* Semáforo: set de colores */
static void semaforo_set(GPIO_PinState rojo, GPIO_PinState amarillo, GPIO_PinState verde)
{
    HAL_GPIO_WritePin(SEM_GPIO, SEM_PIN_ROJO,     rojo);
    HAL_GPIO_WritePin(SEM_GPIO, SEM_PIN_AMARILLO, amarillo);
    HAL_GPIO_WritePin(SEM_GPIO, SEM_PIN_VERDE,    verde);
}

/* Persistir en EEPROM si cambian modo/vel */
static void persist_if_changed(void)
{
    uint8_t modo = (uint8_t)cinta_get_modo(&s_cinta);
    uint8_t vel  = (uint8_t)cinta_get_velocidad(&s_cinta);

    if (modo != s_modo_guardado) {
        EPROM_WriteByte(&hi2c1, EEPROM_ADDR_MODO, modo);
        s_modo_guardado = modo;
    }
    if (vel != s_vel_guardada) {
        EPROM_WriteByte(&hi2c1, EEPROM_ADDR_VEL, vel);
        s_vel_guardada = vel;
    }
}

/* Cargar configuración al iniciar */
static void load_from_eeprom(void)
{
    uint8_t modo = 1;
    uint8_t vel  = 0;

    EPROM_ReadByte(&hi2c1, EEPROM_ADDR_MODO, &modo);
    EPROM_ReadByte(&hi2c1, EEPROM_ADDR_VEL,  &vel);

    if (modo > 2)       modo = 1;
    if (vel > VEL_MAX)  vel  = 0;

    cinta_set_modo(&s_cinta, modo);
    cinta_set_velocidad(&s_cinta, vel);

    s_modo_guardado = modo;
    s_vel_guardada  = vel;
}

/* Semáforo según modo/velocidad (no bloqueante) */
static void semaforo_update(void)
{
    uint32_t now = HAL_GetTick();
    if ((int32_t)(now - s_next_blink_tick) >= 0) {
        s_next_blink_tick = now + BLINK_PERIOD_MS;
        s_blink ^= 1;
    }

    int8_t modo = cinta_get_modo(&s_cinta);
    int8_t vel  = cinta_get_velocidad(&s_cinta);

    if (modo == 0) {
        /* FALLA -> ROJO sólido */
        semaforo_set(GPIO_PIN_SET, GPIO_PIN_RESET, GPIO_PIN_RESET);
    }
    else {
        /* MANUAL / AUTO: indicar velocidad */
        if (vel == 0) {
            semaforo_set(GPIO_PIN_RESET, GPIO_PIN_SET, GPIO_PIN_RESET);                 // amarillo sólido
        } else if (vel == 1) {
            semaforo_set(GPIO_PIN_RESET, GPIO_PIN_RESET, s_blink ? GPIO_PIN_SET : GPIO_PIN_RESET); // verde blink
        } else {
            semaforo_set(GPIO_PIN_RESET, GPIO_PIN_RESET, GPIO_PIN_SET);                 // verde sólido
        }
    }
}

/* Ajustar velocidad en AUTO en base a PAQ, persistiendo si cambia */
static void auto_apply_vel_from_paq(void)
{
    int8_t new_vel = (s_paq_count >= 2) ? 2 : (int8_t)s_paq_count; // 0->0, 1->1, >=2->2
    if (new_vel != cinta_get_velocidad(&s_cinta)) {
        cinta_set_velocidad(&s_cinta, new_vel);
        persist_if_changed();
    }
}

/* ========================= Tarea: init/update ========================= */

void task_sistema_init(void *params)
{
    /* Cinta (modo/velocidad) */
    cinta_inicializar(&s_cinta);

    /* Display */
    displayInit();
    lcd_print_padded(0, 0, "Sistema listo");
    lcd_print_padded(0, 1, "Cargando conf...");

    /* EEPROM -> cargar */
    load_from_eeprom();

    /* Botones: arrancar estado previo */
    for (int i = 0; i < BTN_QTY; i++)
        s_btn_prev[i] = task_sensor_get_state((task_sensor_id_t)i);

    /* Temperaturas (NO bloqueante)
       - Interna: ADC1/TEMPSENSOR (implícito en sen_temp)
       - Externa: ADC2/PA0 (ADC_CHANNEL_0) mapeada 0..100 */
    sen_temp_init(&hadc1, &hadc2, ADC_CHANNEL_0, 100, 3.30f);

    /* Timers */
    s_next_lcd_tick   = HAL_GetTick();
    s_next_blink_tick = HAL_GetTick();
    s_blink           = 0;

    /* Arranque de paquetes/velocidad en AUTO coherente con regla */
    if (cinta_get_modo(&s_cinta) == 2) {
        /* al entrar, PAQ=0 => vel=0 */
        s_paq_count     = 0;
        s_last_paq_tick = HAL_GetTick();
        auto_apply_vel_from_paq();
    }

    /* Pintar modo actual */
    lcd_print_padded(0, 0, modo_to_str(cinta_get_modo(&s_cinta)));
}

void task_sistema_update(void *params)
{
    /* -------- Temperaturas (no bloqueante) -------- */
    sen_temp_update();

    float t;
    if (sen_temp_get_internal(&t))  { s_tin = t; }   /* °C */
    if (sen_temp_get_external(&t))  { s_tex = t; }   /* 0..100 */

    /* -------- Botones (flancos) -------- */
    /* BTN_3: togglear FALLA */
    if (btn_rising_edge(BTN_TOGGLE_FALLA)) {
        if (cinta_get_modo(&s_cinta) == 0) {
            /* salir de FALLA -> MANUAL, restaurar velocidad guardada */
            cinta_set_modo(&s_cinta, 1);
            cinta_set_velocidad(&s_cinta, s_vel_guardada);
        } else {
            /* entrar a FALLA -> vel = 0, y no contamos paquetes */
            cinta_set_modo(&s_cinta, 0);
            cinta_set_velocidad(&s_cinta, 0);
        }
        persist_if_changed();
    }

    /* BTN_1: MANUAL->AUTO, y si ya está en AUTO: PAQ++ */
    if (btn_rising_edge(BTN_PAQ_O_MODO) && cinta_get_modo(&s_cinta) != 0) {
        if (cinta_get_modo(&s_cinta) == 1) {
            /* MANUAL -> AUTO: al entrar, PAQ=0 y vel=0 */
            cinta_set_modo(&s_cinta, 2);
            s_paq_count     = 0;
            s_last_paq_tick = HAL_GetTick();
            auto_apply_vel_from_paq();
            persist_if_changed();
        } else {
            /* AUTO -> contar paquete (saturado en 2) y aplicar velocidad */
            if (s_paq_count < 2) s_paq_count++;
            s_last_paq_tick = HAL_GetTick();
            auto_apply_vel_from_paq();
        }
    }

    /* BTN_2: ciclar velocidad (solo en MANUAL) */
    if (btn_rising_edge(BTN_CYCLE_VEL) && cinta_get_modo(&s_cinta) == 1) {
        int8_t vel = cinta_get_velocidad(&s_cinta);
        vel = (vel >= VEL_MAX) ? VEL_MIN : (vel + 1);
        cinta_set_velocidad(&s_cinta, vel);
        persist_if_changed();
    }

    /* -------- Lógica de timeout de paquetes en AUTO -------- */
    if (cinta_get_modo(&s_cinta) == 2) {
        uint32_t now = HAL_GetTick();
        if (s_paq_count > 0 && (int32_t)(now - s_last_paq_tick) >= (int32_t)PAQ_TIMEOUT_MS) {
            /* Reinicio automático de paquetes y velocidad */
            s_paq_count = 0;
            s_last_paq_tick = now;  /* evita re-disparo inmediato */
            auto_apply_vel_from_paq();  /* setea vel=0 y persiste si cambió */
        }
    }

    /* -------- Semáforo -------- */
    semaforo_update();

    /* -------- LCD (no bloqueante) -------- */
    uint32_t now = HAL_GetTick();
    if ((int32_t)(now - s_next_lcd_tick) >= 0) {

        /* L0: MODO (mantener) */
        lcd_print_padded(0, 0, modo_to_str(cinta_get_modo(&s_cinta)));

        /* L1: VEL y PAQ (nuevo) */
        char l1[21];
        snprintf(l1, sizeof(l1), "VEL:%d  PAQ:%05lu",
                 (int)cinta_get_velocidad(&s_cinta),
                 (unsigned long)s_paq_count);
        lcd_print_padded(0, 1, l1);

        /* L2: TIn (°C con 1 decimal, sin %f) y TEx (0..100) (mantener) */
        int tin10 = (int)(s_tin * 10.0f + (s_tin >= 0 ? 0.5f : -0.5f));  /* décima */
        int tex   = (int)(s_tex + 0.5f);                                 /* entero 0..100 */

        char l2[32];
        snprintf(l2, sizeof(l2), "TIn:%3d.%01dC TEx:%3d",
                 tin10/10, abs(tin10%10),
                 tex);
        lcd_print_padded(0, 2, l2);

        s_next_lcd_tick = now + LCD_PERIOD_MS;
    }
}
