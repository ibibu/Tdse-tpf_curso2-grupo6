/*
 * Aplicación principal (scheduler por tareas) con WCET por semihosting.
 * - Mide cada task_update con DWT->CYCCNT (ciclos -> microsegundos).
 * - Vuelca periódicamente por LOGGER_LOG (semihosting) el last/wcet de cada tarea.
 */

#include <task_sensor_temperature.h>
#include "main.h"
#include "logger.h"

/* ======= ADCs generados por CubeMX ======= */
extern ADC_HandleTypeDef hadc1;   // ADC1: sensor interno de temperatura
extern ADC_HandleTypeDef hadc2;   // ADC2: externo (PA0 -> ADC_CHANNEL_0)

/* ======= Declaración de tareas ======= */
void task_sensor_init(void *params);
void task_sensor_update(void *params);

void task_sistema_init(void *params);
void task_sistema_update(void *params);

/********************** Definiciones y macros ********************************/
#define G_APP_CNT_INI         0ul
#define G_APP_TICK_CNT_INI    0ul

/* Estructura de configuración de tareas */
typedef struct {
    const char *name;              // Nombre para profiling
    void (*task_init)(void *);     // Init
    void (*task_update)(void *);   // Update
    void *parameters;              // Params
} task_cfg_t;

/********************** Configuración de tareas *******************************/
static const task_cfg_t task_cfg_list[] = {
    { "task_sensor",  task_sensor_init,  task_sensor_update,  NULL },  // Botones
    { "task_sistema", task_sistema_init, task_sistema_update, NULL },  // Display + TIn/TEx
};
#define TASK_QTY (sizeof(task_cfg_list)/sizeof(task_cfg_t))

/********************** Profiling (WCET) *************************************/
/* Estructura de perfil por tarea: para registro y dump */
typedef struct {
    const char *name;
    uint32_t    last_cycles;
    uint32_t    wcet_cycles;
    uint32_t    last_us;
    uint32_t    wcet_us;
    uint32_t    calls;
} task_prof_t;

/* Arreglo global (visible si pausás el target o por Memory Browser) */
volatile task_prof_t task_prof[TASK_QTY];

/* Acumulado total por tick */
volatile task_prof_t task_prof_total = {
    .name = "TOTAL_TICK",
    .last_cycles = 0,
    .wcet_cycles = 0,
    .last_us = 0,
    .wcet_us = 0,
    .calls = 0
};

/* ======= Helpers DWT ======= */
static inline void dwt_init(void)
{
    /* Habilitar DWT y el contador de ciclos */
    CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;   // Trace enable
    DWT->CYCCNT = 0;
    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;              // CYCCNT enable
}

static inline uint32_t dwt_get_cycles(void)
{
    return DWT->CYCCNT;
}

static inline uint32_t cycles_to_us(uint32_t cycles)
{
    /* Conversión segura usando 64 bits */
    return (uint32_t)(((uint64_t)cycles * 1000000ull) / (uint64_t)SystemCoreClock);
}

/********************** Variables globales ***********************************/
uint32_t g_app_cnt;                  // Contador principal de ciclos
volatile uint32_t g_app_tick_cnt;    // Contador de ticks para disparar update

/* ===== Dump WCET por semihosting cada N ticks ===== */
static uint32_t s_prof_dump_every = 100;  // cada 100 ticks
static uint32_t s_prof_tick = 0;

static void wcet_dump(void)
{
    LOGGER_LOG("\r\n--- WCET por tarea (us) ---\r\n");
    for (uint32_t i = 0; i < TASK_QTY; i++) {
        LOGGER_LOG("%s: last=%lu us, wcet=%lu us, calls=%lu\r\n",
                   task_prof[i].name,
                   (unsigned long)task_prof[i].last_us,
                   (unsigned long)task_prof[i].wcet_us,
                   (unsigned long)task_prof[i].calls);
    }
    LOGGER_LOG("TOTAL_TICK: last=%lu us, wcet=%lu us, calls=%lu\r\n",
               (unsigned long)task_prof_total.last_us,
               (unsigned long)task_prof_total.wcet_us,
               (unsigned long)task_prof_total.calls);
}

/********************** Implementación de funciones **************************/

/**
 * @brief Inicializa la aplicación y todas las tareas registradas.
 */
void app_init(void)
{
    LOGGER_LOG("\r\n");
    LOGGER_LOG("Iniciando aplicación - Tick [ms] = %lu\r\n", HAL_GetTick());

    g_app_cnt = G_APP_CNT_INI;

    /* Inicializar DWT para medir ciclos */
    dwt_init();

    /* Inicialización del módulo de temperatura (TIn/TEx) */
    sen_temp_init(&hadc1, &hadc2, ADC_CHANNEL_0, 100, 3.30f);

    LOGGER_LOG("Cantidad de tareas: %u\r\n", (unsigned)TASK_QTY);

    /* Inicializar profiling y tareas */
    for (uint32_t i = 0; i < TASK_QTY; i++) {
        task_prof[i].name        = task_cfg_list[i].name;
        task_prof[i].last_cycles = 0;
        task_prof[i].wcet_cycles = 0;
        task_prof[i].last_us     = 0;
        task_prof[i].wcet_us     = 0;
        task_prof[i].calls       = 0;

        if (task_cfg_list[i].task_init != NULL) {
            task_cfg_list[i].task_init(task_cfg_list[i].parameters);
        }
    }
}

/**
 * @brief Actualiza el sistema ejecutando las tareas cuando hay un tick disponible.
 */
void app_update(void)
{
    if (G_APP_TICK_CNT_INI < g_app_tick_cnt) {
        g_app_tick_cnt--;
        g_app_cnt++;

        /* Medición total del tick */
        uint32_t tick_start = dwt_get_cycles();

        /* Ejecutar tareas con profiling */
        for (uint32_t i = 0; i < TASK_QTY; i++) {
            if (task_cfg_list[i].task_update != NULL) {
                uint32_t t0 = dwt_get_cycles();

                task_cfg_list[i].task_update(task_cfg_list[i].parameters);

                uint32_t dt_cycles = dwt_get_cycles() - t0;
                uint32_t dt_us     = cycles_to_us(dt_cycles);

                task_prof[i].last_cycles = dt_cycles;
                task_prof[i].last_us     = dt_us;
                task_prof[i].calls++;

                if (dt_cycles > task_prof[i].wcet_cycles) {
                    task_prof[i].wcet_cycles = dt_cycles;
                    task_prof[i].wcet_us     = dt_us;
                }
            }
        }

        /* Cerrar medición total del tick */
        uint32_t tick_dt_cycles = dwt_get_cycles() - tick_start;
        uint32_t tick_dt_us     = cycles_to_us(tick_dt_cycles);

        task_prof_total.last_cycles = tick_dt_cycles;
        task_prof_total.last_us     = tick_dt_us;
        task_prof_total.calls++;

        if (tick_dt_cycles > task_prof_total.wcet_cycles) {
            task_prof_total.wcet_cycles = tick_dt_cycles;
            task_prof_total.wcet_us     = tick_dt_us;
        }

        /* Volcado periódico por semihosting */
        if ((++s_prof_tick % s_prof_dump_every) == 0) {
            wcet_dump();
        }
    }
}

/**
 * @brief Callback de SysTick: incrementa el contador para disparar las tareas.
 */
void HAL_SYSTICK_Callback(void)
{
    g_app_tick_cnt++;
}
