#include "sistema.h"
#include "cinta.h"
#include "task_sensor.h"
#include "display.h"
#include "eprom.h"
#include "main.h"
#include "stm32f1xx_hal.h"
#include "sen_temp.h"          // <<< agregado
#include <stdio.h>

// --- Variables internas ---
static Cinta cinta_actual;
static char buffer[20];
static uint8_t velocidad_guardada = 0;
static uint8_t contador_auto = 0;
static uint32_t last_pulse_tick = 0;
static uint8_t temperatura = 0;

// Temperaturas no bloqueantes (sen_temp)
static float tin_c = 0.0f;     // interna en °C (real)
static float tex_g = 0.0f;     // externa mapeada 0..100 (pot)

// --- Constantes ---
#define INTERVALO_RESET_MS 10000  // 10s sin pulsos -> reset
#define TEMP_MAX 80              // Umbral de temperatura para falla
#define EEPROM_ADDR_MODO 0x00
#define EEPROM_ADDR_VEL  0x01

extern ADC_HandleTypeDef hadc1;
extern I2C_HandleTypeDef hi2c1;

// --- Prototipos internos ---
static void leer_sensor_temperatura(void);
static void guardar_configuracion(void);
static void leer_configuracion(void);

// --- Funciones ---
static void leer_sensor_temperatura(void)
{
    // *** Mantengo tu lectura original para la línea 1 (VEL y T:xxC) ***
    HAL_ADC_Start(&hadc1);
    if (HAL_ADC_PollForConversion(&hadc1, 10) == HAL_OK) {
        uint16_t valor_adc = HAL_ADC_GetValue(&hadc1);
        temperatura = (valor_adc * 100) / 4095; // Escala 0–100°C
    }
    HAL_ADC_Stop(&hadc1);
}

static void guardar_configuracion(void)
{
    // Guardamos modo y velocidad (solo si no estamos en Falla)
    if (cinta_get_modo(&cinta_actual) != 0) {
        EPROM_WriteByte(&hi2c1, EEPROM_ADDR_MODO, cinta_get_modo(&cinta_actual));
        EPROM_WriteByte(&hi2c1, EEPROM_ADDR_VEL, velocidad_guardada);
    }
}

static void leer_configuracion(void)
{
    uint8_t modo_leido = 1;
    uint8_t vel_leida = 0;

    EPROM_ReadByte(&hi2c1, EEPROM_ADDR_MODO, &modo_leido);
    EPROM_ReadByte(&hi2c1, EEPROM_ADDR_VEL, &vel_leida);

    if (modo_leido == 1 || modo_leido == 2) {
        cinta_set_modo(&cinta_actual, modo_leido);
    } else {
        cinta_set_modo(&cinta_actual, 1); // Valor por defecto
    }

    if (vel_leida <= 2) {
        velocidad_guardada = vel_leida;
    } else {
        velocidad_guardada = 0;
    }

    cinta_set_velocidad(&cinta_actual, velocidad_guardada);
}

void task_sistema_init(void *params)
{
    cinta_inicializar(&cinta_actual);
    HAL_Delay(100);
    displayInit();

    leer_configuracion(); // Restauramos configuración guardada

    displayCharPositionWrite(0, 0);
    displayStringWrite("Sistema Listo ");
    displayCharPositionWrite(0, 1);
    displayStringWrite("Iniciando...");
    HAL_Delay(500);
}

void task_sistema_update(void *params)
{
    // *** Mantengo tu lectura original para la línea 1 ***
    leer_sensor_temperatura();

    // *** Nuevo: traer temperaturas del módulo no bloqueante sen_temp ***
    // (asumo sen_temp ya está inicializado y actualizado desde tu app.c)
    sen_temp_update();  // avanza FSM interna del sensor (no bloqueante)

    float ttmp;
    if (sen_temp_get_internal(&ttmp)) {
        tin_c = ttmp;   // °C reales
    }
    if (sen_temp_get_external(&ttmp)) {
        tex_g = ttmp;   // mapeo 0..100
    }

    // --- Protección por temperatura ---
    if (temperatura > TEMP_MAX && cinta_get_modo(&cinta_actual) != 0) {
        cinta_set_modo(&cinta_actual, 0);
        cinta_set_velocidad(&cinta_actual, 0);
        velocidad_guardada = 0;
        contador_auto = 0;
    }

    // --- BOTÓN 2: Falla ON/OFF ---
    if (task_sensor_get_edge(BTN_2)) {
        if (cinta_get_modo(&cinta_actual) != 0) {
            cinta_set_modo(&cinta_actual, 0);
            cinta_set_velocidad(&cinta_actual, 0);
            velocidad_guardada = 0;
            contador_auto = 0;
        } else {
            cinta_set_modo(&cinta_actual, 1);
            cinta_set_velocidad(&cinta_actual, 0);
        }
    }

    // --- BOTÓN 3: Cambio Manual/Automático ---
    if (task_sensor_get_edge(BTN_3) && cinta_get_modo(&cinta_actual) != 0) {
        if (cinta_get_modo(&cinta_actual) == 1) {
            cinta_set_modo(&cinta_actual, 2);
            contador_auto = 0;
            last_pulse_tick = HAL_GetTick();
            cinta_set_velocidad(&cinta_actual, velocidad_guardada);
        } else {
            cinta_set_modo(&cinta_actual, 1);
            cinta_set_velocidad(&cinta_actual, velocidad_guardada);
        }
        guardar_configuracion();
    }

    // --- BOTÓN 4: Cambio velocidad manual ---
    if (cinta_get_modo(&cinta_actual) == 1 && task_sensor_get_edge(BTN_4)) {
        velocidad_guardada = (velocidad_guardada + 1) % 3;
        cinta_set_velocidad(&cinta_actual, velocidad_guardada);
        guardar_configuracion();
    }

    // --- BOTÓN 1: Contador automático ---
    if (cinta_get_modo(&cinta_actual) == 2 && task_sensor_get_edge(BTN_1)) {
        contador_auto++;
        last_pulse_tick = HAL_GetTick();

        if (contador_auto == 1) {
            velocidad_guardada = 1;
        } else if (contador_auto >= 2) {
            velocidad_guardada = 2;
        }
        cinta_set_velocidad(&cinta_actual, velocidad_guardada);
        guardar_configuracion();
    }

    // --- Reset auto tras 10s sin pulsos ---
    if (cinta_get_modo(&cinta_actual) == 2) {
        if (HAL_GetTick() - last_pulse_tick >= INTERVALO_RESET_MS) {
            contador_auto = 0;
            velocidad_guardada = 0;
            cinta_set_velocidad(&cinta_actual, velocidad_guardada);
            guardar_configuracion();
        }
    }

    // --- Actualizar LCD ---
    displayCharPositionWrite(0, 0);
    if (cinta_get_modo(&cinta_actual) == 0)
        displayStringWrite("MODO: FALLA  ");
    else if (cinta_get_modo(&cinta_actual) == 1)
        displayStringWrite("MODO: MANUAL ");
    else
        displayStringWrite("MODO: AUTO   ");

    displayCharPositionWrite(0, 1);
    int vel_display = (cinta_get_modo(&cinta_actual) == 0) ? 0 : cinta_get_velocidad(&cinta_actual);
    sprintf(buffer, "VEL:%d T:%02dC", vel_display, temperatura);
    displayStringWrite(buffer);

    // --- NUEVO: Línea 3 (índice 2) con TIn y TEx ---
    // Formato sin %f (TIn con 1 decimal, TEx entero 0..100)
    {
        int tin10 = (int)(tin_c * 10.0f + (tin_c >= 0 ? 0.5f : -0.5f));
        int tex   = (int)(tex_g + 0.5f);
        char l3[20];
        // Ej: "TIn: 25.3C TEx: 78"
        snprintf(l3, sizeof(l3), "TIn:%3d.%01dC TEx:%3d",
                 tin10/10, (tin10<0?-(tin10%10):(tin10%10)),
                 tex);
        displayCharPositionWrite(0, 2);
        displayStringWrite(l3);
    }

    // --- Semáforo de LEDs ---
    if (cinta_get_modo(&cinta_actual) == 0) {
        HAL_GPIO_WritePin(GPIOC, GPIO_PIN_8, GPIO_PIN_SET);   // Rojo ON
        HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6, GPIO_PIN_RESET); // Amarillo OFF
        HAL_GPIO_WritePin(GPIOC, GPIO_PIN_5, GPIO_PIN_RESET); // Verde OFF
    } else {
        int vel = cinta_get_velocidad(&cinta_actual);
        if (vel == 0) {
            HAL_GPIO_WritePin(GPIOC, GPIO_PIN_8, GPIO_PIN_RESET);
            HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6, GPIO_PIN_SET);
            HAL_GPIO_WritePin(GPIOC, GPIO_PIN_5, GPIO_PIN_RESET);
        } else {
            HAL_GPIO_WritePin(GPIOC, GPIO_PIN_8, GPIO_PIN_RESET);
            HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6, GPIO_PIN_RESET);
            HAL_GPIO_WritePin(GPIOC, GPIO_PIN_5, GPIO_PIN_SET);
        }
    }
}
